import 'dart:convert';
import 'dart:io' as io;
import 'package:googleapis_auth/auth_io.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:googleapis_auth/googleapis_auth.dart'; // Stelle sicher, dass dieses Package in pubspec.yaml enthalten ist
import 'package:flutter/services.dart' show rootBundle;

class PushNotificationService {
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;
  final FirebaseDatabase _database = FirebaseDatabase.instance;

  /// L√§dt asynchron die Service-Account JSON-Datei
  Future<String> getServiceAccountJson() async {
  try {
    return await rootBundle.loadString('assets/service-account.json');
  } catch (e) {
    print("‚ùå Fehler beim Laden des Service Accounts: $e");
    return "";
  }
}

  /// Initialisiert den PushNotificationService
  Future<void> initialize() async {
    print("üîî PushNotificationService wird gestartet...");

    try {
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
        print("üì± Anfrage f√ºr iOS-Push-Berechtigung...");
        await _firebaseMessaging.requestPermission();
        print("‚úÖ Berechtigungen erteilt");
      }

      if (kIsWeb) {
        print("‚ö†Ô∏è Push-Benachrichtigungen sind auf Web nicht verf√ºgbar.");
        return;
      }

      print("üõ† Lade Service-Account...");
      final String serviceAccountJson = await rootBundle.loadString('assets/service-account.json');
      if (serviceAccountJson.isNotEmpty) {
        print("‚úÖ Service Account erfolgreich geladen.");
      }

      print("üõ† Hole FCM-Token...");
      String? token = await _firebaseMessaging.getToken().timeout(
        Duration(seconds: 5),
        onTimeout: () {
          print("‚ùå Timeout: FCM-Token konnte nicht geholt werden");
          return null;
        },
      );
      print("‚úÖ FCM-Token: ${token ?? 'kein Token erhalten'}");

      await FirebaseMessaging.instance.subscribeToTopic('notifications');
      print("‚úÖ Erfolgreich zum Topic 'notifications' abonniert.");

      // Starte den Listener f√ºr die Firebase-Datenbank
    startDatabaseListener();
    } catch (e) {
      print("‚ùå Fehler in PushNotificationService: $e");
    }
  }

  void startDatabaseListener() {
    DatabaseReference ref = _database.ref("News");

    void processEvent(DatabaseEvent event, String eventType) {
      if (event.snapshot.value is Map) {
        Map<String, dynamic> data = Map<String, dynamic>.from(event.snapshot.value as Map);
        String title = data["title"] ?? "Keine Nachricht verf√ºgbar";
        String newsId = event.snapshot.key ?? "Keine ID verf√ºgbar"; // Schl√ºssel (ID) des Datensatzes

        // Je nach Event-Typ unterschiedliche Benachrichtigungen senden
        if (eventType == "added") {
          print("Neue Nachricht: $title");
          sendPushNotification(title, "Neue Nachricht", newsId);
        } else if (eventType == "changed") {
          print("Nachricht ge√§ndert: $title");
          sendPushNotification(title, "Ge√§nderte Nachricht",newsId);
        }
      } else {
        print("Unerwartetes Datenformat: ${event.snapshot.value}");
      }
    }

    // Listener f√ºr neue Nachrichten und ge√§nderte Nachrichten
    ref.onChildAdded.listen((event) {
      processEvent(event, "added"); // Event-Typ f√ºr neue Nachrichten
    });
    ref.onChildChanged.listen((event) {
      processEvent(event, "changed"); // Event-Typ f√ºr ge√§nderte Nachrichten
    });

    // Listener f√ºr gel√∂schte Nachrichten
    ref.onChildRemoved.listen((event) {
      print("Eintrag wurde gel√∂scht: ${event.snapshot.key}");
    });
  }

  /// Sendet eine Push-Nachricht √ºber die Firebase Cloud Messaging API
  Future<void> sendPushNotification(String type, String title, String newsId) async {
    String? newToken = await FirebaseMessaging.instance.getToken();

    if (newToken==null || newToken.isEmpty || newToken.length < 20) {
      print("‚ö†Ô∏è Fehler: Kein g√ºltiger FCM-Token! Empfangener Token: $newToken");
      return;
    }

    final String? accessToken = await getAccessToken();
    if (accessToken == null) {
      print("‚ùå Fehler: Kein Access Token erhalten!");
      return;
    }

    final Uri url = Uri.parse("https://fcm.googleapis.com/v1/projects/db-teg/messages:send");

    // Erstelle die Nachricht und den Link
    final Map<String, dynamic> payload = {
      "message": {
        "token": newToken,
        "data": {
          "title": type, // Manuell in Flutter auswerten
          "body": title, // Manuell in Flutter auswerten
          "id": newsId
        },
        "android": {
          "priority": "high"
        }
      }
    };

    final response = await http.post(
      url,
      headers: {
        "Authorization": "Bearer $accessToken",
        "Content-Type": "application/json",
      },
      body: jsonEncode(payload),
    );

    if (response.statusCode == 200) {
      print("‚úÖ Push-Nachricht erfolgreich gesendet!");
    } else {
      print("‚ùå Fehler beim Senden der Push-Nachricht: ${response.body}");
    }
  }


  Future<String?> getAccessToken() async {
  try {
    final String serviceAccountJson = await rootBundle.loadString('assets/service-account.json');
    final Map<String, dynamic> serviceAccountData = jsonDecode(serviceAccountJson);

    var credentials = ServiceAccountCredentials.fromJson(serviceAccountData);
    var client = await clientViaServiceAccount(
      credentials,
      ['https://www.googleapis.com/auth/firebase.messaging'],
    );

    return client.credentials.accessToken.data;
  } catch (e) {
    print("Fehler beim Abrufen des Access Tokens: $e");
    return null;
  }
}

}