import 'dart:convert';
import 'dart:io' as io;
import 'package:googleapis_auth/auth_io.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:googleapis_auth/googleapis_auth.dart'; // Stelle sicher, dass dieses Package in pubspec.yaml enthalten ist
import 'package:flutter/services.dart' show rootBundle;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/notification.dart';


class PushNotificationService {
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;
  final FirebaseDatabase _database = FirebaseDatabase.instance;
  bool _listenersInitialized = false;

  /// L√§dt asynchron die Service-Account JSON-Datei
  Future<String> getServiceAccountJson() async {
  try {
    return await rootBundle.loadString('assets/service-account.json');
  } catch (e) {
    print("‚ùå Fehler beim Laden des Service Accounts: $e");
    return "";
  }
}

  /// Initialisiert den PushNotificationService
  Future<void> initialize() async {
    print("üîî PushNotificationService wird gestartet...");

    try {
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
        print("üì± Anfrage f√ºr iOS-Push-Berechtigung...");
        await _firebaseMessaging.requestPermission();
        print("‚úÖ Berechtigungen erteilt");
      }

      startDatabaseListener();
      
      if (kIsWeb) {
        print("‚ö†Ô∏è Push-Benachrichtigungen sind auf Web nicht verf√ºgbar.");
        return;
      }

      print("üõ† Lade Service-Account...");
      final String serviceAccountJson = await rootBundle.loadString('assets/service-account.json');
      if (serviceAccountJson.isNotEmpty) {
        print("‚úÖ Service Account erfolgreich geladen.");
      }

      print("üõ† Hole FCM-Token...");
      String? token = await _firebaseMessaging.getToken().timeout(
        Duration(seconds: 5),
        onTimeout: () {
          print("‚ùå Timeout: FCM-Token konnte nicht geholt werden");
          return null;
        },
      );
      print("‚úÖ FCM-Token: ${token ?? 'kein Token erhalten'}");

      await FirebaseMessaging.instance.subscribeToTopic('notifications');
      print("‚úÖ Erfolgreich zum Topic 'notifications' abonniert.");

      // Starte den Listener f√ºr die Firebase-Datenbank

    } catch (e) {
      print("‚ùå Fehler in PushNotificationService: $e");
    }
  }

  void startDatabaseListener() async {

  if (_listenersInitialized) {
      print("üîÑ Listener bereits aktiv. Kein erneuter Start.");
      return;
    }

    _listenersInitialized = true;

    DatabaseReference ref = _database.ref("News");

    

    void processEvent(DatabaseEvent event, String eventType) async {
  if (event.snapshot.value is Map) {
    Map<String, dynamic> data = Map<String, dynamic>.from(event.snapshot.value as Map);
    String newsId = event.snapshot.key ?? "Keine ID verf√ºgbar"; // Schl√ºssel (ID) des Datensatzes

    TeGNotification n = TeGNotification(
    id: newsId,
  type: data["type"] ?? "Unbekannter Typ",
  title: data["title"] ?? "Keine Nachricht verf√ºgbar",
  body: data["body"] ?? "",
  timestamp: (data["lastUpdate"] is int) 
      ? data["lastUpdate"] 
      : int.tryParse(data["lastUpdate"].toString()) ?? 0, // Sicherstellen, dass immer ein int √ºbergeben wird
);


    int lastFetchTime = await getLastFetchTime();
    
    // Je nach Event-Typ unterschiedliche Benachrichtigungen senden
    if (eventType == "added") {
      if (n.timestamp > lastFetchTime) {
        print("üÜï Neue Nachricht: ${n.title}");
        sendPushNotification(n, newsId);
      }
      await saveLastFetchTime(); // Speichert den Zeitpunkt des Abrufs
    } else if (eventType == "changed") {
      print("Nachricht ge√§ndert: ${n.title}");
      sendPushNotification(n, newsId);
    }
  } else {
    print("Unerwartetes Datenformat: ${event.snapshot.value}");
  }
}
    // Listener f√ºr neue Nachrichten und ge√§nderte Nachrichten
    ref.onChildAdded.listen((event) {
        processEvent(event, "added"); // Event-Typ f√ºr ge√§nderte Nachrichten
    });

    ref.onChildChanged.listen((event) {
      processEvent(event, "changed"); // Event-Typ f√ºr ge√§nderte Nachrichten
    });

    // Listener f√ºr gel√∂schte Nachrichten
    ref.onChildRemoved.listen((event) {
      print("Eintrag wurde gel√∂scht: ${event.snapshot.key}");
    });
  }



Future<void> saveLastFetchTime() async {
  final prefs = await SharedPreferences.getInstance();
  prefs.setInt("lastFetchTime", DateTime.now().millisecondsSinceEpoch);
}

Future<int> getLastFetchTime() async {
  final prefs = await SharedPreferences.getInstance();
  return prefs.getInt("lastFetchTime") ?? 0;
}

  /// Sendet eine Push-Nachricht √ºber die Firebase Cloud Messaging API
  Future<void> sendPushNotification(TeGNotification notifi, String newsId) async {
    String? newToken = await FirebaseMessaging.instance.getToken();

    if (newToken==null || newToken.isEmpty || newToken.length < 20) {
      print("‚ö†Ô∏è Fehler: Kein g√ºltiger FCM-Token! Empfangener Token: $newToken");
      return;
    }

    final String? accessToken = await getAccessToken();
    if (accessToken == null) {
      print("‚ùå Fehler: Kein Access Token erhalten!");
      return;
    }

    final Uri url = Uri.parse("https://fcm.googleapis.com/v1/projects/db-teg/messages:send");

    // Erstelle die Nachricht und den Link
    final Map<String, dynamic> payload = {
      "message": {
        "token": newToken,  // Zielger√§t
        "data": {
          "title": notifi.title,
          "body": notifi.body,
          "id": newsId,
        },
        "android": {
          "priority": "high",
        },
        "apns": {
          "payload": {
            "aps": {
              "content-available": 1,
            }
          }
        }
      }
    };

    final response = await http.post(
      url,
      headers: {
        "Authorization": "Bearer $accessToken",
        "Content-Type": "application/json",
      },
      body: jsonEncode(payload),
    );

    if (response.statusCode == 200) {
      print("‚úÖ Push-Nachricht erfolgreich gesendet!");
    //  await saveNotificationToDatabase(notifi);
    } else {
      print("‚ùå Fehler beim Senden der Push-Nachricht: ${response.body}");
    }
  }

  Future<void> saveNotificationToDatabase(TeGNotification notification) async {
  DatabaseReference dbRef = FirebaseDatabase.instance.ref("notifications");

  await dbRef.push().set(notification.toMap());

  print("‚úÖ Nachricht in der Datenbank gespeichert.");
}


  Future<String?> getAccessToken() async {
  try {
    final String serviceAccountJson = await rootBundle.loadString('assets/service-account.json');
    final Map<String, dynamic> serviceAccountData = jsonDecode(serviceAccountJson);

    var credentials = ServiceAccountCredentials.fromJson(serviceAccountData);
    var client = await clientViaServiceAccount(
      credentials,
      ['https://www.googleapis.com/auth/firebase.messaging'],
    );

    return client.credentials.accessToken.data;
  } catch (e) {
    print("Fehler beim Abrufen des Access Tokens: $e");
    return null;
  }
}

}